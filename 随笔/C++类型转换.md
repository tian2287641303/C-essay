# C++类型转换
C++语言是一个静态类型的强类型语言，存在类型系统，且类型是强制的,会在编译阶段进行类型检查，在大部分情况下编译器必须知道每一个实体对象的类型。对象的类型定义了对象包含的数据和能参与的运算，大部分的类型都支持类型转换运算。但不是每个类型之间都可以相互转换，可以相互转换的两个类型，称这两个类型是关联的。
## 隐式转换 
在程序运行过程中，有时类型转换是自动执行的，无需程序员介入，这就是隐式转换。
### 何时发生隐式类型转换
+ 在大多数表达式中，比int小的整型值首先提升为较大的整型。
+ 在条件中，非布尔值转换为布尔类型。
+ 初始化过程中，初始值转换为变量的类型，在赋值语句中，右侧运算对象转换为左侧运算对象的类型。
+ 如果算数运算或者关系运算的运算对象有多种类型，需要转换为同一种类型。
+ 函数调用时也会发生类型转换。
### 算术类型转换
算术类型转换规则为将运算符的运算对象类型转换为其运算对象最宽的类型，当表达式存在浮点型和整型时，将整型值转化为浮点数。
#### 整型提升
所有比int小的整型类型，在所有可能存入int的情况下，会自动提升为int型，比int大的整型会自动提升到(unsigned int,long,unsigned long,long long,unsigned long long)中能存放下原类型所有可能值的类型中宽度最小的类型。
#### 无符号类型转换 
在运算对象整型提升之后，两个运算对象分别为无符号类型和带符号类型会有两种可能的转换发生
1. 当无符号类型不小于带符号类型时，将带符号类型转换为无符号类型，当带符号类型对象的值为负数时，会用原类型对象值对无符号类型表示总数取模生成转换后对象的值。
2. 对带符号类型大于无符号类型(就是当所有的无符号类型可能取到的值都可以存放在带符号类型)中时，则无符号类型转换为带符号类型。
### 数组转换为指针
在大多数表达式中，数组会自动转换成指向数组首元素的指针。当数组被用作decltype关键字的参数;取地址符,sizeof,typeid等运算符的运算对象时，上述转换不会发生。
### 指针的转换
任意非常量指针可以转换为void*,任意对象的指针可以转换为const void*。
### 转换成布尔类型
算术类型或指针类型可以在某些情况下自动转换为布尔类型，如果原类型的值为0，则为false，否则转换结果为true。
### 转换成常量
允许将指向非常量类型的指针隐式转换为常量类型，但不可以进行相反的转换，因为它试图删除底层const(指向常量的指针)。
### 类类型定义的转换
类类型之间可以通过构造函数进行隐式转换，但每次只能执行一种类类型的转换，同时提出多种类类型的转换会被拒绝。
## 显式转换
有时我们希望将对象强制转换为另一种类型，而将对象强制转换为另一种类型对象的方法就叫做强制类型转换。强制类型转换是非常危险的一种行为
### C语言风格强制类型转换
type(expr);
(type)expr;

### C++风格强制类型转换
格式
cast-name<type>(expr)

C++定义了四种强制转换运算符。
1. static_cast :静态类型转换，会在编译时进行检查，看转换是否能真的完成。
2. const_cast :const_cast只能改变运算对象的底层const，一般用于去掉对象的const性质，但如果对象本身就是一个常量(顶层const)，就会产生为定义的后果。
3. reinterpret_cast :通常为运算对象的位模式提供较低层次的重新解释，c++类型双关，将运算对象所占的内存进行重新解释。
4. dynamic_cast :支持运行时类型识别用于将基类的指针或引用转换为派生类的指针或引用。当转换目标为指针时失败返回结果为0，转换目标为引用失败抛出bad_cast异常。

### 两种风格的优缺点
+ C语言风格的强制类型转换充分利用类型双关，绕开类型系统，直接对内存进行操作，非常自由。但不宜与定位，且非常危险。
+ C++风格风格更加安全,更容易辨认。
### notes
+ 不管是哪种风格的强制转型，如果可以的话都尽量避免使用。
+ 如果必须转型的话，尽量放在函数中

