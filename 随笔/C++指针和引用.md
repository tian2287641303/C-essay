# 复合类型
C++复合类型指的是基于其他类型定义的类型。C++引用和指针都是复合类型。复合类型的声明语句由一个基本数据类型和一个声明符列表组成。
# 引用
引用为类型为对象起了一个名字，引用类型引用另外一种类型，通过添加&在声明符中定义引用类型。引用类型必须初始化，引用并非变量，它在内存上实际上并没有独立的存储空间，引用的本质就是其所绑定的对象的一个别名，对引用进行的所有操作其实都是在其所绑定的对象上进行的，引用定义后不能更改绑定的对象，引用不能绑定引用，字面值，或者表达式的结果。引用定义的类型也需要与其绑定的对象严格匹配。
```
int a = 1;
int& i = a;
```

# 指针
指针是指向另一种类型的复合类型，与引用相似，指针也实现了对其他对象的间接访问，指针本身是一个对象，也存储在内存中，它的宽度由机器字长所决定，指针通过添加*在声明符中声明指针类型，指针存放的是对象的地址，获取对象地址使用&取地址符，指针实际上就是一个保存内存地址的整数。指针定义的类型也需要与其指向的对象严格匹配。

指针的值有四种状态
1. 指向一个对象
2. 指向对象所占空间的下一个位置
3. 空指针
4. 无效指针

当用户试图访问后三种状态的结果都是未知的。用户尽量初始化所有指针，尽量在想要指针指向的对象定义后再来创建指针，或者就初始化成空指针。指针可以通过*解引用符来访问对象，解引用符会返回指向的对象，解引用操作只适用于指向了某个对象的有效地址。

## 空指针
空指针不指向任何对象，得到一个空指针的方法是将指针的值赋为nullptr,0,NULL的一种。
```
int* ptr = 0;
int* ntr = nullptr;
int* str = NULL;
```
## void*指针
void*可以存放任意类型对象的地址，不同的是，编译器并不知道这个地址所指向对象的类型，也就无法直接操作其指向的对象，只能对指针进行一些指针间的比较，函数的输入输出等工作。
```
int a = 5;
void* b = &a;
int c = *(reinterpret_cast<int*>(b));
```

